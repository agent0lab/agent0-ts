/**
 * Generates TypeScript modules from the OASF taxonomy JSON files.
 *
 * Why: Node ESM requires JSON import attributes ("type: json"), which breaks
 * consumers depending on Node version/config. By inlining the taxonomy data into
 * generated TS modules, the published dist contains no JSON imports at runtime.
 */
import { mkdir, readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const projectRoot = path.resolve(__dirname, '..');
const srcDir = path.join(projectRoot, 'src');
const taxonomiesDir = path.join(srcDir, 'taxonomies');
const outDir = path.join(taxonomiesDir, 'generated');

function tsHeader(sourceRelPath) {
  return `/**
 * AUTO-GENERATED FILE â€” DO NOT EDIT.
 *
 * Source: ${sourceRelPath}
 * Generated by: scripts/generate-taxonomies.mjs
 */
/* eslint-disable */
`;
}

function tsModuleFor(jsonObject, typeName) {
  const json = JSON.stringify(jsonObject, null, 2);
  return `${tsHeader(`src/taxonomies/${typeName}.json`)}

const data = ${json} as unknown;

export default data;
`;
}

async function generateOne(basename) {
  const inPath = path.join(taxonomiesDir, `${basename}.json`);
  const outPath = path.join(outDir, `${basename}.ts`);

  const raw = await readFile(inPath, 'utf8');
  const parsed = JSON.parse(raw);

  const ts = `${tsHeader(`src/taxonomies/${basename}.json`)}

const data = ${JSON.stringify(parsed, null, 2)} as unknown;

export default data;
`;

  await writeFile(outPath, ts, 'utf8');
}

async function main() {
  await mkdir(outDir, { recursive: true });

  await Promise.all([generateOne('all_skills'), generateOne('all_domains')]);
}

main().catch((err) => {
  // eslint-disable-next-line no-console
  console.error(err);
  process.exitCode = 1;
});


